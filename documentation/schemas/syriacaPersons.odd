<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:srophe="https://srophe.app">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Customization for Syriaca.org Persons Data</title>
      </titleStmt>
      <editionStmt>
        <edition n="0.9"/>
      </editionStmt>
      <publicationStmt>
        <authority>Syriaca.org: The Syriac Reference Portal</authority>
        <availability>
          <licence target="http://creativecommons.org/licenses/by/3.0/">
            <p>Distributed under a Creative Commons Attribution 3.0 Unported License.</p>
            <p>The code examples contained in <gi>exemplum</gi> elements below come from 
              Syriaca.org projects that have been distributed under a Creative Commons Attribution 
              3.0 Unported License. Used by permission.</p>
            <p>The comments on element and attribute use contained in <gi>remarks</gi> elements below 
              share some text with other Syriaca.org documentation distributed under a Creative Commons 
              Attributiion 3.0 Unported License. This documentation can be found at various links available here:
              <ref target="http://syriaca.org/documentation/index.html">http://syriaca.org/documentation/index.html</ref>
              Used by permission.
            </p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>This ODD provides a customization of the TEI P5 All. It is the second link in an ODD chain
          that uses the <title ref="https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/schemas/srophe.compiled.odd">
            TEI Customization for Syriaca.org</title> as its source. 
        </p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <schemaSpec ident="syriacaPersons" prefix="tei_" source="syriacaAll.compiled.odd" xml:lang="en" defaultExceptions="http://www.tei-c.org/ns/1.0 teix:egXML​ http://www.example.org/ns/">
        <moduleRef key="tei"/>
        <moduleRef key="certainty" include="precision"/>
        <moduleRef key="core" include="author bibl choice citedRange date desc editor foreign listBibl name note orig p ptr quote reg ref resp respStmt title"/>
        <moduleRef key="header" include="authority availability catDesc category change classDecl edition editionStmt editorialDecl encodingDesc fileDesc funder idno interpretation langUsage licence principal profileDesc publicationStmt revisionDesc seriesStmt sourceDesc sponsor taxonomy teiHeader titleStmt"/>
        <moduleRef key="linking" include="link"/>
        <moduleRef key="namesdates" include="addName birth death event floruit forename gender listPerson listRelation orgName persName person personGrp placeName relation roleName state surname trait"/>
        <moduleRef key="textstructure" include="body TEI text"/>
        <classRef key="att.global.analytic"/>
        <classRef key="att.global.change"/>
        
        
        
        
        
        <elementSpec ident="birth" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.canonical" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="true" minOccurs="1">
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="body" module="textstructure" mode="change">
          <content>
            <elementRef key="listPerson" minOccurs="1" maxOccurs="1"/>
          </content>
          <remarks mode="replace">
            <p>The <gi>body</gi> element of a person record must contain a <gi>listPerson</gi> element.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="death" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.canonical" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="true">
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="event" module="namesdates" mode="change">
          <!-- compare syriacaPlaces.odd for possible development -->
          
        </elementSpec>
        
        
        <elementSpec ident="floruit" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="false">
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="persName" minOccurs="0" maxOccurs="1"/>
              <textNode/>
            </sequence>
          </content>
          <attList>
            <attDef ident="xml:id" mode="delete"/>
            <attDef ident="n" mode="delete"/>
            <attDef ident="ana" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
          </attList>
        </elementSpec>
        
        
       <elementSpec ident="gender" module="namesdates" mode="change">
         <classes mode="change">
           <memberOf key="att.datable" mode="delete"/>
           <memberOf key="att.typed" mode="delete"/>
         </classes>
         <content>
           <textNode/>
         </content>
         <attList>
           <attDef ident="xml:id" mode="delete"/>
           <attDef ident="n" mode="delete"/>
           <attDef ident="xml:lang" mode="delete"/>
           <attDef ident="change" mode="delete"/>
           <attDef ident="rend" mode="delete"/>
           <attDef ident="corresp" mode="delete"/>
           <attDef ident="previous" mode="delete"/>
           <attDef ident="value" mode="delete"/>
         </attList>
        </elementSpec>
        
        
        <elementSpec ident="idno" module="header" mode="change">
          <!-- see syriacaPlaces for possible developments -->
          
        </elementSpec>
        
        
        <elementSpec ident="listPerson" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.declarable" mode="delete"/>
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="false">
              <alternate>
                <elementRef key="person" minOccurs="1" maxOccurs="1"/>
                <elementRef key="personGrp" minOccurs="1" maxOccurs="1"/>
              </alternate>
              <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
            </sequence>
          </content>
        </elementSpec>
        
        
        <elementSpec ident="note" module="core" mode="change">
          
        </elementSpec>
        
        
        <elementSpec ident="orgName" module="core" mode="change">
          <classes mode="change">
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="false">
              <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
              <textNode/>
            </sequence>
          </content>
          <attList>
            <attDef ident="key" mode="delete"/>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="ana" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
            <attDef ident="sort" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="key" mode="delete"/>
            <attDef ident="srophe:tags" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="persName" module="namesdates" mode="change">
          <constraintSpec ident="source-on-persName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:person/tei:persName | //tei:text//tei:personGrp/tei:persName">
                <sch:assert test="attribute::source or attribute::resp">
                  This &lt;persName&gt; element must have either a @source attribute (preferred when available) or a @resp attribute.
                </sch:assert>
                <sch:report test="attribute::source and attribute::resp">
                  This &lt;persName&gt; element may not have both a @source attribute (the preferred when available) and a @resp attribute.
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="persName-content" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:persName">
                <sch:assert test="string-length(.) gt 0">The &lt;persName&gt; element cannot be empty.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <!-- This works in the schematron but not when placed into the ODD and converted to RelaxNG. There is a namespace issue I will try to troubleshoot.
            <constraintSpec ident="langHeadword" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:let name="langsOfHW" value="//tei:place/tei:placeName[@srophe:tags='#syriaca-headword']/@xml:lang"/>
                <sch:assert test="count(./parent::tei:place/tei:placeName[@xml:lang='en' and @srophe:tags='#syriaca-headword']) = 1">
                  There can be one and only one &lt;placeName&gt; element with the combination of @srophe:tags="#syriaca-headword" and @xml:lang="en".
                </sch:assert>
                <sch:assert test="count(distinct-values($langsOfHW)) = count($langsOfHW)">
                  There cannot be more than one headword (@srophe:tags="#syriaca-headword") per &lt;placeName&gt; with the same language (@xml:lang).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>-->
          <constraintSpec ident="xmlID-on-persName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:person/tei:persName | //tei:text//tei:personGrp/tei:persName">
                <sch:let name="docURIno" value="//tei:publicationStmt/tei:idno[@type='URI']/substring-before(substring-after(substring-after(., 'http://syriaca.org/'), '/'), '/tei')"/>
                <sch:assert test="matches(./@xml:id, concat('name', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'name<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="xmlLang-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:person/tei:persName | //tei:text//tei:personGrp/tei:persName">
                <sch:assert test="./@xml:lang">A &lt;persName&gt; element that is the direct child of &lt;person&gt; or &lt;personGrp&gt; must have an @xml:lang attribute.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" mode="change">
              <desc>
                The <gi>persName</gi> element requires an <att>xml:id</att> attribute whose value is the concatenation of "name", 
                the Syriaca.org ID number of this place (i.e. the last element of the URI), a ‘-’, and the number of this name element in order.
              </desc>
            </attDef>
            <attDef ident="xml:lang" mode="change">
              <desc>
                The language of the name should be indicated in an <att>xml:lang</att> attribute of the <gi>persName</gi> element, 
                whose value is derived from the the <ref target="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO-639-1 or ISO-639-2 standards</ref>. 
                In particular, "en" should be used for "English", "ar" for "Arabic", and "syr" for Syriac. Syriaca.org is not using "syc" for 
                Syriac to avoid the judgment of what constitutes "classical." In the case of vocalized Syriac, the <att>xml:lang</att> attribute 
                should be augmented with a script indication: either "-Syrj" to indicate West Syrian vocalization or "-Syrn" to indicate East Syrian 
                vocalization. Thus the <att>xml:lang</att> attribute will have a value of "syr-Syrj" for vocalized Western Syriac and "syr-Syrn" 
                for vocalized Eastern Syriac. The <att>xml:lang</att> attribute for an unvocalized Syriac name form, such as Syriaca.org’s headword 
                form, should be simply "syr".
              </desc>
            </attDef>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="person" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="link" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/> <!-- This needs to be changed to minOccurs="1". Every record needs an abstract. -->
              <elementRef key="floruit" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="birth" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="death" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="gender" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="trait" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="sex" mode="delete"/>
            <attDef ident="gender" mode="delete"/>
            <attDef ident="age" mode="delete"/>
          </attList>
         </elementSpec>
        
                
        
        
        <elementSpec ident="personGrp" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="link" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/> <!-- This needs to be changed to minOccurs="1". Every record needs an abstract. -->
              <elementRef key="floruit" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="birth" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="death" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="gender" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="trait" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="sex" mode="delete"/>
            <attDef ident="gender" mode="delete"/>
            <attDef ident="age" mode="delete"/>
            <attDef ident="size" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="placeName" module="core" mode="change">
          <attList>
            <attDef ident="xml:id" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="sort" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="key" mode="delete"/>
            <attDef ident="ref" mode="change" usage="req"/>
            <attDef ident="srophe:tags" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="ptr" module="core" mode="change">
          
        </elementSpec>
        
        
        
        <elementSpec ident="relation" module="namesdates" mode="change">
          <constraintSpec ident="documentation-on-relation" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:relation">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="atts-on-relation" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:relation/@mutual">
                <sch:let name="personIndex" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/indexes/persons.xml')"/>
                <sch:let name="personURIs" value="$personIndex//tei:place/@ref"/>
                <sch:assert test="                   every $i in tokenize(., ' ')                   satisfies $i = $personURIs">
                  This attribute contains one or more person URIs not in use in Syriaca.org data. Note that all person URIs take the form 'http://syriaca.org/person/{\d+?}' (where {\d+?} is a number).
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation/@active">
                <sch:let name="personIndex" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/indexes/persons.xml')"/>
                <sch:let name="personURIs" value="$personIndex//tei:place/@ref"/>
                <sch:assert test="                   every $i in tokenize(., ' ')                   satisfies $i = $personURIs">
                  This attribute contains one or more person URIs not in use in Syriaca.org data. Note that all person URIs take the form 'http://syriaca.org/person/{\d+?}' (where {\d+?} is a number).
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='pseudonymity']/@passive">
                <sch:let name="personIndex" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/indexes/persons.xml')"/>
                <sch:let name="personURIs" value="$personIndex//tei:place/@ref"/>
                <sch:assert test="                   every $i in tokenize(., ' ')                   satisfies $i = $personURIs">
                  This attribute contains one or more person URIs not in use in Syriaca.org data. Note that all person URIs take the form 'http://syriaca.org/person/{\d+?}' (where {\d+?} is a number).
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='place']/@passive">
                <sch:let name="placeIndex" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/indexes/places.xml')"/>
                <sch:let name="placeURIs" value="$placeIndex//tei:place/@ref"/>
                <sch:assert test=". = $placeURIs">
                  This attribute contains one or more place URIs not in use in Syriaca.org data. Note that all place URIs take the form 'http://syriaca.org/plcae/{\d+?}' (where {\d+?} is a number).
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active"><!-- This doesn't seem to be working even though in works in the schematron test document -->
                <sch:let name="docURI" value="//tei:publicationStmt/tei:idno/substring-before(., '/tei')"/>
                <sch:assert test="contains(., $docURI)">
                  This attribute must contain the URI for this document's place: <sch:value-of select="$docURI"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/distinct-entity']">
                <sch:assert test="@type='disambiguation' and @mutual and not(@ana)">
                  For a 'distinct entity' relationship use @type="disambiguation", and a @mutual, and not @ana.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/possibly-identical']">
                <sch:assert test="@type='disambiguation' or @type='pseudonymity' and @mutual and not(@ana)">
                  For a 'possibly identical' relationship use either @type="disambiguation" or @type="pseudonymity", and a @mutual, and not @ana.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/shares-attribution-with']">
                <sch:assert test="@type='pseudonymity' and @mutual and not(@ana)">
                  For a 'share-attribution-with' relationship, use @type="pseudonymity" and a @mutual attribute.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='skos:broader']">
                <sch:assert test="@type='pseudonymity' and @active and not(@ana)">
                  For a 'broader' relationship, use @type="pseudonymity" and @active/@passive attributes.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/has-relation-to-place']">
                <sch:assert test="@type='place' and @active">
                  For a 'has-relation-to-place' relationship, use @type="place" and @active/@passive attributes.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/has-literary-relation-to-place']">
                <sch:assert test="@type='place' and @active">
                  For a 'has-literary-relation-to-place' relationship, use @type="place" and @active/@passive attributes.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='disambiguation']">
                <sch:assert test="@ref='http://syriaca.org/keyword/distinct-entity' or @ref='http://syriaca.org/keyword/possibly-identical'">
                  With @type="disambiguation", the @ref attribute must be either "http://syriaca.org/keyword/distinct-entity" or "http://syriaca.org/keyword/possibly-identical".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='pseudonymity']">
                <sch:assert test="@ref='http://syriaca.org/keyword/possibly-identical' or @ref='http://syriaca.org/keyword/shares-attribution-with' or @ref='skos:broader'">
                  With @type="pseudonymity", the @ref attribute must be either "http://syriaca.org/keyword/possibly-identical", "http://syriaca.org/keyword/shares-attribution-with", or "skos:broader".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='place']">
                <sch:assert test="@ref='http://syriaca.org/keyword/has-relation-to-place' or @ref='http://syriaca.org/keyword/has-literary-relation-to-place'">
                  With @type="place", the @ref attribute must be either "http://syriaca.org/keyword/has-relation-to-place" or "http://syriaca.org/keyword/has-literary-relation-to-place".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="personal-relations-ref" scheme="schematron">
            <constraint>
              <sch:rule context="tei:listPerson//tei:relation[@type = 'personal']/@ref">
                <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:assert test=". = $ti//listURI[@type = 'relationships']//uri">Value must be one of the following from the Syriaca.org taxonomy:
                  <sch:value-of select="string-join($ti//listURI[@type = 'relationships']//uri, ';  ')"/>.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:listPerson//tei:relation[@type = 'personal']/@ana">
                <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:let name="qrURI" value="$ti//listURI[@type = 'qualifier-relationship']//uri"/>
                <sch:let name="error" value="."/>
                <sch:assert test="
                  every $i in (tokenize(., ' '))
                  satisfies $i = $qrURI">
                  <sch:value-of select="$error"/> is not currently in use. The value of this @ref attribute must be one of the following: <sch:value-of select="string-join($qrURI, ';  ')"/>.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="replace" usage="req">
              <valList type="closed" mode="replace">
                <valItem ident="disambiguation">
                  <desc>Used for relationships that disambiguate between people with similar names or who have been confused in the scholarship</desc>
                </valItem>
                <valItem ident="pseudonymity">
                  <desc>Used to describe relationships between persons variously identified in a situation of pseudonymous authorship</desc>
                </valItem>
                <valItem ident="personal">
                  <desc>Used for person and professional relationships</desc>
                </valItem>
                <valItem ident="place">
                  <desc>Used for relationships between a person and a place other than birth and death</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" mode="delete"/>
            <attDef ident="ref" mode="replace" usage="req">
              <datatype maxOccurs="1" minOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valList type="semi" mode="replace">
                <valItem ident="http://syriaca.org/keyword/distinct-entity">
                  <desc>Used to distinguish between entities that have been confused in the scholarly literature or might be 
                    confused by users.</desc>
                </valItem>
                <valItem ident="http://syriaca.org/keyword/possibly-identical">
                  <desc>Used to indicate that even though Syriaca.org has identified this location as a distinct entity, it 
                    is possible that this entity is the same an another entity with a Syriaca.org URI.</desc>
                </valItem>
                <valItem ident="http://syriaca.org/keyword/shares-attribution-with">
                  <desc>Used for pseudonymous authorship to indicate the relationship between the supposed author (i.e. Ephrem) and the 
                    otherwise unknown "pseudo" author (i.e. Pseudo-Ephrem).</desc>
                </valItem>
                <valItem ident="skos:broader">
                  <desc>Used for pseudonymous authorship to indicate the relationship between the unknown author of a specific work and the 
                    scholarly composite used to refer to author of multiple texts (i.e. Pseudo-Ephrem).</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="seriesStmt" module="header" mode="change">
          <!-- see places for development ideas -->
        </elementSpec>
        
        
        
        <elementSpec ident="state" module="namesdates" mode="change">
          
        </elementSpec>
        
        
        <elementSpec ident="title" module="core" mode="change">
          
        </elementSpec>
        
        
        <elementSpec ident="trait" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
          </classes>
          <content>
            <elementRef key="desc" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="subtype" mode="delete"/>
            <attDef ident="xml:id" mode="delete"/>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="ana" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
      </schemaSpec>
      
    </body>
  </text>
</TEI>
