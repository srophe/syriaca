<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:srophe="https://srophe.app">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Customization for Syriaca.org Persons Data</title>
      </titleStmt>
      <editionStmt>
        <edition n="0.9"/>
      </editionStmt>
      <publicationStmt>
        <authority>Syriaca.org: The Syriac Reference Portal</authority>
        <availability>
          <licence target="http://creativecommons.org/licenses/by/3.0/">
            <p>Distributed under a Creative Commons Attribution 3.0 Unported License.</p>
            <p>The code examples contained in <gi>exemplum</gi> elements below come from 
              Syriaca.org projects that have been distributed under a Creative Commons Attribution 
              3.0 Unported License. Used by permission.</p>
            <p>The comments on element and attribute use contained in <gi>remarks</gi> elements below 
              share some text with other Syriaca.org documentation distributed under a Creative Commons 
              Attributiion 3.0 Unported License. This documentation can be found at various links available here:
              <ref target="http://syriaca.org/documentation/index.html">http://syriaca.org/documentation/index.html</ref>
              Used by permission.
            </p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>This ODD provides a customization of the TEI P5 All. It is the second link in an ODD chain
          that uses the <title ref="https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/schemas/srophe.compiled.odd">
            TEI Customization for Syriaca.org</title> as its source. 
        </p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <schemaSpec ident="syriacaPersons" prefix="tei_" source="syriacaAll.compiled.odd" xml:lang="en" defaultExceptions="http://www.tei-c.org/ns/1.0 teix:egXML​ http://www.example.org/ns/">
        <moduleRef key="tei"/>
        <moduleRef key="certainty" include="precision"/>
        <moduleRef key="core" include="author bibl choice citedRange date desc editor foreign listBibl name note orig p ptr quote reg ref resp respStmt title"/>
        <moduleRef key="header" include="authority availability catDesc category change classDecl edition editionStmt editorialDecl encodingDesc fileDesc funder idno interpretation langUsage licence principal profileDesc publicationStmt revisionDesc seriesStmt sourceDesc sponsor taxonomy teiHeader titleStmt"/>
        <moduleRef key="linking" include="link"/>
        <moduleRef key="namesdates" include="addName birth death event floruit forename gender listPerson listRelation orgName persName person personGrp placeName relation roleName state surname trait"/>
        <moduleRef key="textstructure" include="body TEI text"/>
        <classRef key="att.global.analytic"/>
        <classRef key="att.global.change"/>
        
        
        
        
        
        <elementSpec ident="birth" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.canonical" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="true" minOccurs="1">
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="body" module="textstructure" mode="change">
          <content>
            <elementRef key="listPerson" minOccurs="1" maxOccurs="1"/>
          </content>
          <remarks mode="replace">
            <p>The <gi>body</gi> element of a person record must contain a <gi>listPerson</gi> element.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="death" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.canonical" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="true">
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="event" module="namesdates" mode="change">
          <!-- compare syriacaPlaces.odd for possible development -->
          
        </elementSpec>
        
        
        <elementSpec ident="floruit" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="false">
              <elementRef key="date" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="persName" minOccurs="0" maxOccurs="1"/>
              <textNode/>
            </sequence>
          </content>
          <attList>
            <attDef ident="xml:id" mode="delete"/>
            <attDef ident="n" mode="delete"/>
            <attDef ident="ana" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
          </attList>
        </elementSpec>
        
        
       <elementSpec ident="gender" module="namesdates" mode="change">
         <classes mode="change">
           <memberOf key="att.datable" mode="delete"/>
           <memberOf key="att.typed" mode="delete"/>
         </classes>
         <content>
           <textNode/>
         </content>
         <attList>
           <attDef ident="xml:id" mode="delete"/>
           <attDef ident="n" mode="delete"/>
           <attDef ident="xml:lang" mode="delete"/>
           <attDef ident="change" mode="delete"/>
           <attDef ident="rend" mode="delete"/>
           <attDef ident="corresp" mode="delete"/>
           <attDef ident="previous" mode="delete"/>
           <attDef ident="value" mode="delete"/>
         </attList>
        </elementSpec>
        
        
        <elementSpec ident="idno" module="header" mode="change">
          <!-- see syriacaPlaces for possible developments -->
          
        </elementSpec>
        
        
        <elementSpec ident="listPerson" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.declarable" mode="delete"/>
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="false">
              <alternate>
                <elementRef key="person" minOccurs="1" maxOccurs="1"/>
                <elementRef key="personGrp" minOccurs="1" maxOccurs="1"/>
              </alternate>
              <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
            </sequence>
          </content>
        </elementSpec>
        
        
        <elementSpec ident="note" module="core" mode="change">
          
        </elementSpec>
        
        
        <elementSpec ident="orgName" module="core" mode="change">
          <classes mode="change">
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>
          <content>
            <sequence preserveOrder="false">
              <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
              <textNode/>
            </sequence>
          </content>
          <attList>
            <attDef ident="key" mode="delete"/>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="ana" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
            <attDef ident="sort" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="key" mode="delete"/>
            <attDef ident="srophe:tags" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="persName" module="namesdates" mode="change">
          <constraintSpec ident="source-on-persName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:person/tei:persName | //tei:text//tei:personGrp/tei:persName">
                <sch:assert test="attribute::source or attribute::resp">
                  This &lt;persName&gt; element must have either a @source attribute (preferred when available) or a @resp attribute.
                </sch:assert>
                <sch:report test="attribute::source and attribute::resp">
                  This &lt;persName&gt; element may not have both a @source attribute (the preferred when available) and a @resp attribute.
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="persName-content" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:persName">
                <sch:assert test="string-length(.) gt 0">The &lt;persName&gt; element cannot be empty.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <!-- This works in the schematron but not when placed into the ODD and converted to RelaxNG. There is a namespace issue I will try to troubleshoot.
            <constraintSpec ident="langHeadword" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:let name="langsOfHW" value="//tei:place/tei:placeName[@srophe:tags='#syriaca-headword']/@xml:lang"/>
                <sch:assert test="count(./parent::tei:place/tei:placeName[@xml:lang='en' and @srophe:tags='#syriaca-headword']) = 1">
                  There can be one and only one &lt;placeName&gt; element with the combination of @srophe:tags="#syriaca-headword" and @xml:lang="en".
                </sch:assert>
                <sch:assert test="count(distinct-values($langsOfHW)) = count($langsOfHW)">
                  There cannot be more than one headword (@srophe:tags="#syriaca-headword") per &lt;placeName&gt; with the same language (@xml:lang).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>-->
          <constraintSpec ident="xmlID-on-persName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:person/tei:persName | //tei:text//tei:personGrp/tei:persName">
                <sch:let name="docURIno" value="//tei:publicationStmt/tei:idno[@type='URI']/substring-before(substring-after(substring-after(., 'http://syriaca.org/'), '/'), '/tei')"/>
                <sch:assert test="matches(./@xml:id, concat('name', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'name<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="xmlLang-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:person/tei:persName | //tei:text//tei:personGrp/tei:persName">
                <sch:assert test="./@xml:lang">A &lt;persName&gt; element that is the direct child of &lt;person&gt; or &lt;personGrp&gt; must have an @xml:lang attribute.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" mode="change">
              <desc>
                The <gi>persName</gi> element requires an <att>xml:id</att> attribute whose value is the concatenation of "name", 
                the Syriaca.org ID number of this place (i.e. the last element of the URI), a ‘-’, and the number of this name element in order.
              </desc>
            </attDef>
            <attDef ident="xml:lang" mode="change">
              <desc>
                The language of the name should be indicated in an <att>xml:lang</att> attribute of the <gi>persName</gi> element, 
                whose value is derived from the the <ref target="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO-639-1 or ISO-639-2 standards</ref>. 
                In particular, "en" should be used for "English", "ar" for "Arabic", and "syr" for Syriac. Syriaca.org is not using "syc" for 
                Syriac to avoid the judgment of what constitutes "classical." In the case of vocalized Syriac, the <att>xml:lang</att> attribute 
                should be augmented with a script indication: either "-Syrj" to indicate West Syrian vocalization or "-Syrn" to indicate East Syrian 
                vocalization. Thus the <att>xml:lang</att> attribute will have a value of "syr-Syrj" for vocalized Western Syriac and "syr-Syrn" 
                for vocalized Eastern Syriac. The <att>xml:lang</att> attribute for an unvocalized Syriac name form, such as Syriaca.org’s headword 
                form, should be simply "syr".
              </desc>
            </attDef>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="person" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="link" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/> <!-- This needs to be changed to minOccurs="1". Every record needs an abstract. -->
              <elementRef key="floruit" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="birth" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="death" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="gender" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="trait" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="sex" mode="delete"/>
            <attDef ident="gender" mode="delete"/>
            <attDef ident="age" mode="delete"/>
          </attList>
         </elementSpec>
        
                
        
        
        <elementSpec ident="personGrp" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
              <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="link" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/> <!-- This needs to be changed to minOccurs="1". Every record needs an abstract. -->
              <elementRef key="floruit" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="birth" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="death" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="gender" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="trait" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="previous" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="sex" mode="delete"/>
            <attDef ident="gender" mode="delete"/>
            <attDef ident="age" mode="delete"/>
            <attDef ident="size" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="placeName" module="core" mode="change">
          <attList>
            <attDef ident="xml:id" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="sort" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="key" mode="delete"/>
            <attDef ident="ref" mode="change" usage="req"/>
            <attDef ident="srophe:tags" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="ptr" module="core" mode="change">
          
        </elementSpec>
        
        
        
        <elementSpec ident="relation" module="namesdates" mode="change">
          <constraintSpec ident="person-disambiguation-atts" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:listPerson//tei:relation[@type = 'disambiguation']">
                <sch:assert test="@mutual">
                  A &lt;relation&gt; with @type="disambiguation" must have a @mutual attribute.</sch:assert>
              </sch:rule>
              <sch:rule context="//tei:listPerson//tei:relation[@type = 'disambiguation']/@ref">
                <sch:assert test=". = 'http://syriaca.org/keyword/distinct-entities' or . = 'http://syriaca.org/keyword/possibly-identical'">
                  A &lt;relation&gt; with @type="disambiguation" must have @ref="http://syriaca.org/keyword/distinct-entities" or @ref="http://syriaca.org/keyword/possibly-identical".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="pseudonymity-atts" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:listPerson//tei:relation[@type = 'pseudonymity']/@ref">
                <sch:assert test=". = 'http://syriaca.org/keyword/possibly-identical' or . = 'http://syriaca.org/keyword/shares-attribution-with' or . = 'skos:broader'">
                  The @ref attribute on &lt;relation&gt; with @type="pseudonymity" can only be one of the following "http://syriaca.org/keyword/distinct-entities", "http://syriaca.org/keyword/shares-attribution-with", or "skos:broader".</sch:assert>
              </sch:rule>
              <sch:rule context="//tei:listPerson//tei:listRelation[tei:relation[@type = 'pseudonymity']]">
                <sch:assert test="tei:relation/@ref = 'http://syriaca.org/keyword/possibly-identical'">
                  There must be a &lt;relation&gt; element with @ref="http://syriaca.org/keyword/possibly-identical".</sch:assert>
                <sch:assert test="tei:relation/@ref = 'http://syriaca.org/keyword/shares-attribution-with'">
                  There must be a &lt;relation&gt; element with @ref="http://syriaca.org/keyword/shares-attribution-with".</sch:assert>
                <sch:assert test="tei:relation/@ref = 'skos:broader'">
                  There must be a &lt;relation&gt; element with @ref="skos:broader".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="personal-relations-atts" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:listPerson//tei:relation[@type = 'personal']/@ref">
                <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:assert test=". = $ti//listURI[@type = 'relationships']//uri">Value must be one of the following from the Syriaca.org taxonomy:
                  <sch:value-of select="string-join($ti//listURI[@type = 'relationships']//uri, ';  ')"/>.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:ab/tei:listRelation/tei:relation/@ana">
                <sch:let name="ti" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/taxonomyIndex-old.xml')"/>
                <sch:let name="qrURI" value="$ti//listURI[@type = 'qualifier-relationship']//uri"/>
                <sch:let name="error" value="."/>
                <sch:assert test="
                  every $i in (tokenize(., ' '))
                  satisfies $i = $qrURI">
                  <sch:value-of select="$error"/> is not currently in use. The value of this @ana attribute must be one of the following: <sch:value-of select="string-join($qrURI, ';  ')"/>.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="person-place-relation-atts" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:listPerson//tei:relation[@type = 'place']">
                <sch:assert test="@active">
                  A &lt;relation&gt; with @type="place" must have an @active attribute.</sch:assert>
              </sch:rule>
              <sch:rule context="//tei:listPerson//tei:relation[@type = 'place']/@ref">
                <sch:assert test=". = 'http://syriaca.org/keyword/has-relation-to-place' or . = 'http://syriaca.org/keyword/has-literary-relation-to-place'">
                  The @ref attribute on &lt;relation&gt; with @type="place" can only be one of the following "http://syriaca.org/keyword/has-relation-to-place" or "http://syriaca.org/keyword/has-literary-relation-to-place".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <valList type="closed">
                <valItem ident="disambiguation">
                  <desc>Used for relationships that disambiguate between people with similar names or who have been confused in the scholarship</desc>
                </valItem>
                <valItem ident="pseudonymity">
                  <desc>Used to describe relationships between persons variously identified in a situation of pseudonymous authorship</desc>
                </valItem>
                <valItem ident="personal">
                  <desc>Used for person and professional relationships</desc>
                </valItem>
                <valItem ident="place">
                  <desc>Used for relationships between a person and a place other than birth and death</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="seriesStmt" module="header" mode="change">
          <!-- see places for development ideas -->
        </elementSpec>
        
        
        
        <elementSpec ident="state" module="namesdates" mode="change">
          
        </elementSpec>
        
        
        <elementSpec ident="title" module="core" mode="change">
          
        </elementSpec>
        
        
        <elementSpec ident="trait" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.dimensions" mode="delete"/>
            <memberOf key="att.ranging" mode="delete"/>
          </classes>
          <content>
            <elementRef key="desc" minOccurs="1" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="subtype" mode="delete"/>
            <attDef ident="xml:id" mode="delete"/>
            <attDef ident="n" mode="delete"/>
            <attDef ident="xml:lang" mode="delete"/>
            <attDef ident="ana" mode="delete"/>
            <attDef ident="change" mode="delete"/>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="rend" mode="delete"/>
            <attDef ident="corresp" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
      </schemaSpec>
      
    </body>
  </text>
</TEI>
