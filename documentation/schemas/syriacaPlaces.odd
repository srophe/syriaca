<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:srophe="https://srophe.app">
  
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Customization for Syriaca.org Place Data</title>
        <editor role="creator" ref="http://syriaca.org/documentation/editors.xml#dschwartz">Daniel L. Schwartz</editor>
      </titleStmt>
      <editionStmt>
        <edition n="0.9"/>
      </editionStmt>
      <publicationStmt>
        <authority>Syriaca.org: The Syriac Reference Portal</authority>
        <availability>
          <licence target="http://creativecommons.org/licenses/by/3.0/">
            <p>Distributed under a Creative Commons Attribution 3.0 Unported License.</p>
            <p>The code examples contained in <gi>exemplum</gi> elements below come from 
              Syriaca.org projects that have been distributed under a Creative Commons Attribution 
              3.0 Unported License. Used by permission.</p>
            <p>The comments on element and attribute use contained in <gi>remarks</gi> elements below 
              share some text with other Syriaca.org documentation distributed under a Creative Commons 
              Attributiion 3.0 Unported License. This documentation can be found at various links available here:
              <ref target="http://syriaca.org/documentation/index.html">http://syriaca.org/documentation/index.html</ref>
              Used by permission.
            </p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>This ODD provides a customization of the TEI P5 All. It is the third link in an ODD chain
          and uses the <title ref="https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/schemas/syriacaAll.compiled.odd">
            TEI Customization for Syriaca.org</title> as its source. 
        </p>
      </sourceDesc>
    </fileDesc>
    <profileDesc>
      <!-- Instructions for processing the Syriaca.org chained ODD in oXygen.
        - First, be sure that schemaSpec/@source in this document points to "syriacaAll.compiled.odd".
        - Then process this ODD file into a compiled ODD using the transformation scenario "ODD to Compiled ODD".
          - Save this as syriacaPlaces.compiled.odd and then delete the @start attribute from tei:schemaSpec.
          - This compiled ODD (without a tei:schemaSpec/@start attribute) will be the starting point for the next step in the chained ODD.
        - This compiled ODD can also be used to generate a .rng file against which you can validate a TEI document. 
          - You generate this file using the transformation scenario "TEI ODD to RELAX NG XML".
          - After you have generated the Relax NG, you need to add xmlns:srophe="https://srophe.app" to the grammar element at the top of that file. -->
    </profileDesc>
  </teiHeader>
   
  
  <text>
    <body>
      
      <schemaSpec ident="syriacaPlaces" prefix="tei_" source="syriacaAll.compiled.odd" xml:lang="en" defaultExceptions="http://www.tei-c.org/ns/1.0 teix:egXML​ http://www.example.org/ns/">
        <moduleRef key="tei"/>
        <moduleRef key="certainty" include="precision"/>
        <moduleRef key="core" include="abbr author bibl biblScope choice citedRange date desc editor expan foreign listBibl measure name note orig p ptr quote reg ref resp respStmt title"/>
        <moduleRef key="header" include="authority availability catDesc category change classDecl edition editionStmt editorialDecl encodingDesc fileDesc funder idno langUsage licence principal profileDesc publicationStmt revisionDesc seriesStmt sourceDesc sponsor taxonomy teiHeader titleStmt"/>
        <moduleRef key="linking" include="link"/>
        <moduleRef key="namesdates" include="event geo listPlace listRelation location offset persName place placeName relation state"/>
        <moduleRef key="tagdocs" include="gi"/>
        <moduleRef key="textstructure" include="TEI body text"/>
        <classRef key="att.global.analytic"/>
        <classRef key="att.global.change"/>
        
        
        
        <elementSpec ident="bibl" module="core" mode="change">
          <constraintSpec ident="xmlID-on-bibl" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:place/child::tei:bibl">
                <sch:let name="docURIno" value="replace(//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/text(), '.+?(\d+).+', '$1')"/>
                <sch:let name="id" value="@xml:id"/>
                <sch:assert test="matches(./@xml:id, concat('bib', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'bib<sch:value-of select="$docURIno"/>-{\d+}' (where {\d+} is a number).
                </sch:assert>
                <sch:report test="preceding-sibling::element()[@xml:id = $id]">This @xml:id is already in use.</sch:report>
              </sch:rule>
              <sch:rule context="tei:text//tei:bibl[not(parent::tei:place)]">
                <sch:report test="@xml:id">This &lt;bibl&gt; cannot contain an @xml:id.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        
        
        <elementSpec ident="biblScope" module="core" mode="change">
          <constraintSpec ident="biblScope-in-seriesStmt" scheme="schematron">
            <constraint>
              <sch:rule context="tei:seriesStmt/tei:biblScope/@unit">
                <sch:assert test=". = 'volume'">The @unit must be "volume".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="unit" mode="change" usage="req">
              <valList type="closed" mode="replace">
                <valItem ident="volume"/>
              </valList>
            </attDef>
            <attDef ident="n" mode="change" usage="req"/>
          </attList>
        </elementSpec>
             
        
        
        <elementSpec ident="body" module="textstructure" mode="change">
          <content>
            <elementRef key="listPlace" minOccurs="1" maxOccurs="1"/>
          </content>
          <remarks mode="replace">
            <p>The <gi>body</gi> element of a Syriaca.org place record must contain a <gi>listPlace</gi> element.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="date" module="namesdates" mode="change">
          <attList>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        
        <elementSpec ident="desc" module="core" mode="change">
          <constraintSpec ident="documentation-on-place-desc" scheme="schematron">
            <constraint>
              <sch:rule context="tei:place/tei:desc">
                <sch:report test="@resp and @source">Only one of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
              <sch:rule context="tei:location/tei:desc">
                <sch:report test="@resp or @source">Documentation using @resp or @source should go on the parent &lt;location&gt; element.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="place-desc-child-quote" scheme="schematron">
            <constraint>
              <sch:rule context="tei:place/tei:desc[not(tei:quote)]">
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="confession-desc" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:state/tei:desc">
                <!-- Revisit this. It works but it is inelegent. 
            The problem is that it is difficult to combine regex and schematron functions to move between lowercase w/ hypens to uppercase without.-->
                <sch:let name="confessionDoc" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/confessions.xml')"/>
                <sch:let name="confessionLabels" value="$confessionDoc//tei:text//tei:item/tei:label"/>
                <sch:let name="stateRefPart" value="substring-after(parent::tei:state/@ref, '#')"/>
                <sch:let name="spaceTo-" value="for $i in . return(replace($i, ' ', '-'))"/>
                <sch:let name="labelToRef" value="for $i in $spaceTo- return lower-case($spaceTo-)"/>
                <sch:assert test="parent::tei:state/@type='confession'">A &lt;label&gt; element can only be used when parent &lt;state&gt; element has @type="confession"</sch:assert>
                <sch:assert test="every $i in $labelToRef satisfies $i = $stateRefPart">
                  The text node in the &lt;label&gt; element must correspond to the @ref attribute on the parent &lt;state&gt;: 
                  <sch:value-of select="parent::tei:state/@ref"/>.
                </sch:assert>
                <sch:assert test="every $i in . satisfies $i = $confessionLabels">
                  The text node in the &lt;label&gt; element must be one of the following: <sch:value-of select="string-join($confessionLabels, '; ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        
        
        
        <elementSpec ident="event" module="namesdates" mode="change">
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <desc>The <gi>event</gi> element requires a <att>type</att> attribute.</desc>
              <valList type="closed" mode="replace">
                <valItem ident="attestation">
                  <desc>An event that attests to the entity described in the document</desc>
                </valItem>
                <valItem ident="other">
                  <desc>Any event that does something other than attest to the entity described in the document</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="idno" module="header" mode="change">
          
        </elementSpec>
        
        
        
        <elementSpec ident="listPlace" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <elementRef key="place" minOccurs="1" maxOccurs="1"/>
            <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
          </content>
          <remarks mode="add">
            <p>The <gi>listPlace</gi> element of a place record must contain a <att>place</att> 
              element and may contain a <gi>listRelation</gi> element.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="location" module="namesdates" mode="change">
          <!--<classes mode="change">
            <memberOf key="att.global.rendition" mode="delete"/><!-\- not deleted -\->
            <memberOf key="att.global.linking" mode="delete"/><!-\- not deleted -\->
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            
          </classes>-->
          <content>
            <alternate>
              <elementRef key="geo"/>
              <elementRef key="desc"/>
            </alternate>
          </content>
          <constraintSpec ident="location-children" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:location[@type='gps']">
                <sch:assert test="./tei:geo">
                  A &lt;location&gt; element of @type="gps" requires a child element &lt;geo&gt;.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:location[@type='relative']">
                <sch:assert test="./tei:desc">
                  A &lt;location&gt; element of @type="relative" requires a child elements: &lt;desc&gt;.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="documentation-on-location" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:location">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
              <sch:rule context="tei:place/tei:location[not(tei:quote)]">
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="subtype-on-location" scheme="schematron">
            <constraint>
              <sch:rule context="tei:location[@subtype='preferred']">
                <sch:report test="not(@type='gps')">The attribute @subtype with value "preferred" can only be used with @type="gps".</sch:report>
                <sch:report test=".[@type='gps'][@subtype='preferred'][preceding-sibling::tei:location[@type='gps'][@subtype='preferred']]">
                  The data already contains a preferred gps location and only one is allowed.</sch:report>
              </sch:rule>
              <sch:rule context="tei:location[count(../tei:location[@type='gps']) > 1][@type='gps']">
                <sch:assert test="@subtype">
                  When there are two or more gps locations, the &lt;location&gt; element must contain a @subtype attribute.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <valList mode="replace" type="closed">
                <valItem ident="gps"/>
                <valItem ident="relative"/>
              </valList>
            </attDef>
            <attDef ident="subtype" mode="change">
              <valList mode="replace" type="closed">
                <valItem ident="preferred">
                  <desc>Indicates a preferred location when the data contains multiple locations</desc>
                </valItem>
                <valItem ident="alternate">
                  <desc>Indicates a non-preferred location when the data contains multiple location</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="source" mode="change">
              <desc>
                In most cases the <gi>location</gi> element will have a <att>source</att> attribute pointing to the <gi>bibl</gi> element that is the 
                source of that location information. In instances were the location information has been collected by a Syriaca.org contributor but is
                not attested in print, a <att>resp</att> is used with a value of 'http://syriaca.org'.
              </desc>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="measure" module="core" mode="change">
          <!--<classes mode="change"><!-\- all deleted -\->
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.global.rendition" mode="delete"/>
            <memberOf key="att.global.linking" mode="delete"/>
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            <memberOf key="att.global.responsibility" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>-->
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="note" module="core" mode="change">
          <constraintSpec ident="note-type-deprecation" scheme="schematron"> <!-- Changes to relation elements will require this to change. -->
            <constraint>
              <sch:rule context="//tei:body//tei:note[@type='deprecation']">
                <sch:assert test="./@target">
                  A &lt;note&gt; element of @type="deprecation" must have a @target attribute.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:text//tei:note[@type='deprecation']/@target">
                <sch:let name="nameIDs" value="//tei:place/tei:placeName/@xml:id"/>
                <sch:let name="IDvalues" value="for $i in $nameIDs return concat('#', $i)"/>
                <sch:assert test="every $i in tokenize(., ' ') satisfies $i = $IDvalues">
                  This @target attribute on &lt;note&gt; of @type="deprecation" can take one or more of the following value 
                  separated by a space: 
                  <sch:value-of select="string-join($IDvalues, ' | ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="note-type-disambiguation" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:text//tei:note[@type='disambiguation']">
                <sch:assert test="./tei:idno">
                  A &lt;note&gt; element of @type="disambiguation" must have an &lt;idno&gt; element pointing to an identifier in a dataset external to Syriaca.org.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:text//tei:note[@type='disambiguation']/tei:idno">
                <sch:report test="contains(., 'syriaca.org')">
                  This &lt;idno&gt; element cannot contain a Syriaca.org URI. It is used to disambiguate an entity with a Syriaca.org URI from an external entity. 
                </sch:report>
              </sch:rule>
              <sch:rule context="//tei:body//tei:note[@type='deprecation']/@target">
                <sch:let name="nameIDs" value="//tei:place/tei:placeName/@xml:id"/>
                <sch:let name="IDvalues" value="for $i in $nameIDs return concat('#', $i)"/>
                <sch:assert test="every $i in tokenize(., ' ') satisfies $i = $IDvalues">
                  This @target attribute on &lt;note&gt; of @type="deprecation" can take one or more of the following value 
                  separated by a space: 
                  <sch:value-of select="string-join($IDvalues, ' | ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="corresp" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="offset" module="namesdates" mode="change">
          <!--<classes mode="change"><!-\- all deleted -\->
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.datable.w3c" mode="delete"/>
            
            <memberOf key="att.datable.custom" mode="delete"/>
            
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.global.rendition" mode="delete"/>
            <memberOf key="att.global.linking" mode="delete"/>
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            <memberOf key="att.global.responsibility" mode="delete"/>
            <memberOf key="att.global.source" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>-->
          <!--<attList>
            
            <attDef ident="ref" mode="change" usage="req"/>
          </attList>-->
        </elementSpec>
        
        
        
        
        <elementSpec ident="persName" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
          </classes>
          <attList>
            <attDef ident="sort" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="key" mode="delete"/>
            <attDef ident="srophe:tags" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="place" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <elementRef key="placeName" minOccurs="1" maxOccurs="unbounded"/>
            <elementRef key="desc" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="location" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
            <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <constraintSpec ident="person-abstract-req" scheme="schematron">
            <constraint>
              <sch:rule context="tei:place">
                <sch:assert test="tei:desc[@type='abstract']">Every place record must have at least one &lt;desc&gt; @type="abstract".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="subtype" mode="delete"/>
            <attDef ident="type" mode="replace" usage="req">
              <valList type="closed" mode="replace"> <!-- This should be migrated to LOD when possible -->
                <valItem ident="building">
                  <desc>A construction for which there is no narrower category, such as a church or mosque. Examples of this type include palaces and named city gates.</desc>
                </valItem>
                <valItem ident="cemetery">
                </valItem>
                <valItem ident="church">
                </valItem>
                <valItem ident="composite">
                  <desc>A named place concept which merges multiple distinct place types, such as a city and a diocese. More specific types are preferred.</desc>
                </valItem>
                <valItem ident="designated-space">
                  <desc>An area with artificial boundaries which is not necessarily built up, such as a cemetery, town square, or polo ground.</desc>
                </valItem>
                <valItem ident="diocese">
                  <desc>An ecclesiastical province governed by a bishop, archbishop, or metropolitan.</desc>
                </valItem>
                <valItem ident="fortification">
                  <desc>A military outpost such as a fort or a castle.</desc>
                </valItem>
                <valItem ident="island">
                  <desc>A land-mass smaller than a continent surrounded on all sides by water.</desc>
                </valItem>
                <valItem ident="madrasa">
                  <desc>A building or space designated for instruction in the Islamic sciences.</desc>
                </valItem>
                <valItem ident="monastery">
                  <desc>A whole monastic complex, including living quarters for the monks or nuns, the church(es), and potentially a refectory, library, school, or other part.</desc>
                </valItem>
                <valItem ident="mosque">
                  <desc>A building or designated space used for Muslim congregational prayers. It can be part of a larger building complex.</desc>
                </valItem>
                <valItem ident="mountain">
                  <desc>An elevated physical feature, from Mt. Ararat down to a prominent hill.</desc>
                </valItem>
                <valItem ident="natural-feature">
                  <desc>A natural feature for which there is no narrower category, such as a mountain or open water. Examples of this type include forests and hot springs.</desc>
                </valItem>
                <valItem ident="open-water">
                  <desc>A broad category for seas, lakes, oceans, and ponds.</desc>
                </valItem>
                <valItem ident="parish">
                  <desc>An ecclesiastical region below a diocese, presided over by a priest.</desc>
                </valItem>
                <valItem ident="province">
                  <desc>A political unit subject to a "state" but larger than a city. States often have multiple levels of administrative units (e.g. the late Ottoman vilayets, sanjaks, kazas, and nahiyes), all of which can be indicated as a "province."</desc>
                </valItem>
                <valItem ident="quarter">
                  <desc>A subdivision of an urban center.</desc>
                </valItem>
                <valItem ident="region">
                  <desc>A term indicating a geographic extent larger than a city, without a corresponding politico-administrative apparatus. The size could range from a small valley to an entire continent.</desc>
                </valItem>
                <valItem ident="river">
                  <desc>A stream of water of whatever size, from the smallest creek to the Amazon. Wadis are also included, even if they are not filled with water year-round.</desc>
                </valItem>
                <valItem ident="settlement">
                  <desc>Any collection of civilian residences, from the smallest village to the largest metropolis.</desc>
                </valItem>
                <valItem ident="state">
                  <desc>A sovereign government such as an empire, kingdom, caliphate, or independent emirate.</desc>
                </valItem>
                <valItem ident="synagogue">
                  <desc>A building designated for use in Jewish worship.</desc>
                </valItem>
                <valItem ident="temple">
                  <desc>A building designated for use in pagan worship.</desc>
                </valItem>
                <valItem ident="unknown">
                  <desc>A place whose name is known, but what sort of place it represents is unknown.</desc>
                </valItem>
                <valItem ident="valley">
                </valItem>
              </valList>
            </attDef>
          </attList>
          <remarks mode="add">
            <p>Within each <gi>place</gi> element will be a series of: 
              one or more <gi>placeName</gi> elements,
              zero or more <gi>location</gi> elements,
              zero or more <gi>event</gi> elements,
              zero or more <gi>state</gi> elements,
              one or more <gi>note</gi> description elements,
              one or more <gi>idno</gi> elements, and
              one or more <gi>bibl</gi> elements.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="placeName" module="namesdates" mode="change">
          <constraintSpec ident="documentation-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:place//tei:placeName[not(parent::tei:place)]">
                <sch:report test="@source and @resp">Neither of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="placeName-content" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:place/tei:placeName">
                <sch:assert test="string-length(.) gt 0">The &lt;placeName&gt; element cannot be empty.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <!-- This works in the schematron but not when placed into the ODD and converted to RelaxNG. There is a namespace issue I will try to troubleshoot.
            <constraintSpec ident="langHeadword" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:let name="langsOfHW" value="//tei:place/tei:placeName[@srophe:tags='#syriaca-headword']/@xml:lang"/>
                <sch:assert test="count(./parent::tei:place/tei:placeName[@xml:lang='en' and @srophe:tags='#syriaca-headword']) = 1">
                  There can be one and only one &lt;placeName&gt; element with the combination of @srophe:tags="#syriaca-headword" and @xml:lang="en".
                </sch:assert>
                <sch:assert test="count(distinct-values($langsOfHW)) = count($langsOfHW)">
                  There cannot be more than one headword (@srophe:tags="#syriaca-headword") per &lt;placeName&gt; with the same language (@xml:lang).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>-->
          <constraintSpec ident="xmlID-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text/tei:place/tei:placeName">
                <sch:let name="docURIno" value="replace(//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/text(), '.+?(\d+).+', '$1')"/>
                <sch:let name="id" value="@xml:id"/>
                <sch:assert test="matches(./@xml:id, concat('name', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'name<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
                <sch:report test="preceding-sibling::element()[@xml:id = $id]">This @xml:id is already in use.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="xmlLang-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:place/tei:placeName">
                <sch:assert test="./@xml:lang">A &lt;placeName&gt; element that is the direct child of the &lt;place&gt; element must have an @xml:lang attribute.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" mode="change">
              <desc>
                The <gi>placeName</gi> element requires an <att>xml:id</att> attribute whose value is the concatenation of "name", 
                the Syriaca.org ID number of this place (i.e. the last element of the URI), a ‘-’, and the number of this name element in order.
              </desc>
            </attDef>
            <attDef ident="xml:lang" mode="change">
              <desc>
                The language of the name should be indicated in an <att>xml:lang</att> attribute of the <gi>placeName</gi> element, 
                whose value is derived from the the <ref target="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO-639-1 or ISO-639-2 standards</ref>. 
                In particular, "en" should be used for "English", "ar" for "Arabic", and "syr" for Syriac. Syriaca.org is not using "syc" for 
                Syriac to avoid the judgment of what constitutes "classical." In the case of vocalized Syriac, the <att>xml:lang</att> attribute 
                should be augmented with a script indication: either "-Syrj" to indicate West Syrian vocalization or "-Syrn" to indicate East Syrian 
                vocalization. Thus the <att>xml:lang</att> attribute will have a value of "syr-Syrj" for vocalized Western Syriac and "syr-Syrn" 
                for vocalized Eastern Syriac. The <att>xml:lang</att> attribute for an unvocalized Syriac name form, such as Syriaca.org’s headword 
                form, should be simply "syr".
              </desc>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        
        
        <elementSpec ident="relation" module="namesdates" mode="change">
          <constraintSpec ident="documentation-on-relation" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:relation">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="atts-on-relation" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active | tei:text//tei:relation/@passive">
                <sch:let name="placeIndex" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/indexes/places.xml')"/>
                <sch:let name="placeURIs" value="$placeIndex//tei:place/@ref"/>
                <sch:assert test="every $i in tokenize(., ' ') satisfies $i = $placeURIs">
                  This attribute contains one or more place URIs not in use in Syriaca.org data. Note that all place URIs take the form 'http://syriaca.org/place/{\d+?}' (where {\d+?} is a number).
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active"><!-- This doesn't seem to be working even though in works in the schematron test document -->
                <sch:let name="docURI" value="//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/substring-before(., '/tei')"/>
                <sch:assert test="contains(., $docURI)">
                  This attribute must contain the URI for this document's place: <sch:value-of select="$docURI"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='disambiguation']">
                <sch:assert test="@ref='http://syriaca.org/keyword/conceptually-related' or @ref='http://syriaca.org/keyword/co-located' or @ref='http://syriaca.org/keyword/not-to-be-confused-with' or @ref='http://syriaca.org/keyword/share-a-name'">
                  With @type="disambiguation", the @ref attribute must be one of the following "http://syriaca.org/keyword/conceptually-related", "http://syriaca.org/keyword/co-located", "http://syriaca.org/keyword/not-to-be-confused-with", or "http://syriaca.org/keyword/share-a-name".</sch:assert>
                <sch:assert test="@mutual">
                  This relationship requires a @mutual attribute.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='see-also']">
                <sch:assert test="@ref='http://www.w3.org/2004/02/skos/core#related'">
                  With @type="see-also", the @ref attribute must be "http://www.w3.org/2004/02/skos/core#related".</sch:assert>
                <sch:assert test="@mutual">
                  This relationship requires a @mutual attribute.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@type='contained-within']">
                <sch:assert test="@ref='http://www.w3.org/2004/02/skos/core#broader'">
                  With @type="contained-within", the @ref attribute must be "http://www.w3.org/2004/02/skos/core#broader".</sch:assert>
                <sch:assert test="@active and @passive">
                  This relationship requires @active/@passive attributes.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/conceptually-related']">
                <sch:assert test="@type='disambiguation'">
                  This relationship requires @type="disambiguation".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/co-located']">
                <sch:assert test="@type='disambiguation'">
                  This relationship requires @type="disambiguation".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/not-to-be-confused-with']">
                <sch:assert test="@type='disambiguation'">
                  This relationship requires @type="disambiguation".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://syriaca.org/keyword/share-a-name']">
                <sch:assert test="@type='disambiguation'">
                  This relationship requires @type="disambiguation".</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://www.w3.org/2004/02/skos/core#broader']">
                <sch:assert test="@type='contained-within'">
                  This relationship requires @type="contained-within"</sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='http://www.w3.org/2004/02/skos/core#related']">
                <sch:assert test="@type='disambiguation'">
                  For a 'related' relationship, use @type="see-also".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="replace" usage="req">
              <valList type="closed">
                <valItem ident="disambiguation">
                  <desc>Used for a group of relationships that disambiguate between entities.</desc>
                </valItem>
                <valItem ident="contained-within">
                  <desc>Used for a nesting relationship and indicates when are larger entity contains the subject of an authority file.</desc>
                </valItem>
                <valItem ident="see-also">
                  <desc>Used when the encoder wants to point user to another entity they may want to see.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" mode="delete">
              <!--<valList type="closed" mode="change">
                <valItem ident="share-a-name">
                  <desc>Used with disambiguation relationships when the entities have the same or a very similar name. 
                    This could either be a situation in which two otherwise unrelated places share a name, i.e. two 
                    churches in different locations with the name "Saint George", or a situation in which a city, 
                    the diocese associated with that city, and the region around that city all share a name.
                  </desc>
                </valItem>
              </valList>-->
            </attDef>
            <attDef ident="ref" mode="replace" usage="req">
              <valList type="closed">
                <valItem ident="http://syriaca.org/keyword/conceptually-related">
                  <desc>Used to indicate when this entity is closely related conceptually to another entity, i.e. a settlement, its diocese, and its region.</desc>
                </valItem>
                <valItem ident="http://syriaca.org/keyword/co-located">
                  <desc>Used to indicate when distinct entities share a location and therefore might be confused.</desc>
                </valItem>
                <valItem ident="http://syriaca.org/keyword/not-to-be-confused-with">
                  <desc>Used to distinguish between entities that have been confused in the scholarly literature or might be confused by users.</desc>
                </valItem>
                <valItem ident="http://syriaca.org/keyword/possibly-identical">
                  <desc>Used to indicate that even though Syriaca.org has identified this location as a distinct entity, it is possible that this place is the same an another entity.</desc>
                </valItem>
                <valItem ident="http://syriaca.org/keyword/share-a-name">
                  <desc>Used to indicate when entities share a name but remain distinct; i.e. when different settlements or churches share a name.</desc>
                </valItem>
                  <valItem ident="http://www.w3.org/2004/02/skos/core#broader">
                  <desc>Used for a nesting relationship and indicates when a larger entity contains the subject of this authority file.</desc>
                </valItem>
                <valItem ident="http://www.w3.org/2004/02/skos/core#related">
                  <desc>Used for a "see-also" relationship.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="seriesStmt" module="header" mode="change">
          <constraintSpec ident="seriesStmt-series" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:seriesStmt/tei:title[@level='s']">
                <sch:assert test="./node() = 'The Syriac Gazetteer' or ./node() = 'A Guide to John of Ephesus'">
                  This &lt;title&gt; element must be "The Syriac Gazetteer" or "A Guide to John of Ephesus". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title = 'The Syriac Gazetteer']/tei:idno">
                <sch:assert test="matches(., 'http://syriaca.org/geo')">
                  This &lt;idno&gt; element must contain "http://syriaca.org/geo". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title = 'A Guide to John of Ephesus']/tei:idno">
                <sch:assert test="matches(., 'http://syriaca.org/johnofephesus')">
                  This &lt;idno&gt; element must contain "http://syriaca.org/johnofephesus". 
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="seriesStmt-monograph" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:seriesStmt/tei:title[@level='m']">
                <sch:assert test="./node() = 'Beth Qaṭraye Gazetteer' or ./node() = 'Gazetteer to John of Ephesus’s Ecclesiastical History'">
                  This &lt;title&gt; element must be "Beth Qaṭraye Gazetteer" or "Gazetteer to John of Ephesus’s Ecclesiastical History". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title='Beth Qaṭraye Gazetteer']/tei:idno">
                <sch:assert test="matches(., 'http://syriaca.org/bethqatraye')">
                  This &lt;idno&gt; element must be "http://syriaca.org/bethqatraye". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title='Beth Qaṭraye Gazetteer']">
                <sch:assert test="tei:biblScope/@n = '1'">
                  Requires a &lt;biblScope&gt; element with @n="1" since the "Beth Qaṭraye Gazetteer" is volume 1 of "The Syriac Gazetteer".
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title='Gazetteer to John of Ephesus’s Ecclesiastical History']/tei:idno">
                <sch:assert test="matches(., 'http://syriaca.org/johnofephesus/places')">
                  This &lt;idno&gt; element must be "http://syriaca.org/johnofephesus/places". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title='Gazetteer to John of Ephesus’s Ecclesiastical History']">
                <sch:assert test="tei:biblScope/@n = '2'">
                  Requires a &lt;biblScope&gt; element with @n="2" since the "Gazetteer to John of Ephesus’s Ecclesiastical History" is volume 2 of "The Syriac Gazetteer".
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        
        
        
        <elementSpec ident="state" module="namesdates" mode="change">
          <constraintSpec ident="xmlID-on-state" scheme="schematron">
            <constraint>
              
            </constraint>
          </constraintSpec>
          <constraintSpec ident="state-type-existence" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:state[@type='existence']">
                <sch:assert test="attribute::source or attribute::resp">
                  Must have either a @source attribute (preferred when available) or a @resp attribute.
                </sch:assert>
                <sch:report test="attribute::source and attribute::resp">
                  Not allowed to take both a @source attribute (the preferred when available) and a @resp attribute.
                </sch:report>
                <sch:report test="@xml:id">
                  An @xml:id attribute not allowed here.
                </sch:report>
                <sch:report test="@ref">
                  A @ref attribute not allowed here.
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="state-type-confession" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:state[@type='confession']">
                <sch:let name="docURIno" value="replace(//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/text(), '.+?(\d+).+', '$1')"/>
                <sch:let name="id" value="@xml:id"/>
                <sch:assert test="@ref">Must have a @ref attribute.</sch:assert>
                <sch:assert test="matches(./@xml:id, concat('confession', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'confession<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
                <sch:report test="preceding-sibling::element()[@xml:id = $id]">This @xml:id is already in use.</sch:report>
              </sch:rule>
              <sch:rule context="//tei:state[@type='confession']/@ref"><!-- Add rule pointing to Taxonomy when development allows. -->
                <sch:let name="confessionDoc" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/confessions.xml')"/>
                <sch:let name="confessionIDs" value="$confessionDoc//tei:text//tei:item/@xml:id"/>
                <sch:let name="confessionPtrs" value="for $i in $confessionIDs return concat('#', $i)"/>
                <sch:let name="confessionRefValues" value="for $i in $confessionPtrs return concat('http://syriaca.org/documentation/confessions.xml', $i)"/>
                <sch:assert test="every $i in . satisfies $i = $confessionRefValues">
                  The acceptable values of @ref are 'http://syriaca.org/documentation/confessions.xml' followed by one of the following:
                  <sch:value-of select="string-join($confessionPtrs, '; ')"/>
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <valList type="closed" mode="change">
                <valItem ident="confession">
                  <desc>identifies the presence of a confessional community in this place</desc>
                </valItem>
                <valItem ident="existence">
                  <desc>indicates that the place existed</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
      </schemaSpec>
    </body>
  </text>
</TEI>