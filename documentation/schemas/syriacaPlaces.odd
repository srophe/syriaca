<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:srophe="https://srophe.app">
  
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Customization for Syriaca.org Place Data</title>
        <editor role="creator" ref="http://syriaca.org/documentation/editors.xml#dschwartz">Daniel L. Schwartz</editor>
      </titleStmt>
      <editionStmt>
        <edition n="0.9"/>
      </editionStmt>
      <publicationStmt>
        <authority>Syriaca.org: The Syriac Reference Portal</authority>
        <availability>
          <licence target="http://creativecommons.org/licenses/by/3.0/">
            <p>Distributed under a Creative Commons Attribution 3.0 Unported License.</p>
            <p>The code examples contained in <gi>exemplum</gi> elements below come from 
              Syriaca.org projects that have been distributed under a Creative Commons Attribution 
              3.0 Unported License. Used by permission.</p>
            <p>The comments on element and attribute use contained in <gi>remarks</gi> elements below 
              share some text with other Syriaca.org documentation distributed under a Creative Commons 
              Attributiion 3.0 Unported License. This documentation can be found at various links available here:
              <ref target="http://syriaca.org/documentation/index.html">http://syriaca.org/documentation/index.html</ref>
              Used by permission.
            </p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>This ODD provides a customization of the TEI P5 All. It is the third link in an ODD chain
          and uses the <title ref="https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/schemas/syriacaAll.compiled.odd">
            TEI Customization for Syriaca.org</title> as its source. 
        </p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  
  <text>
    <body>
      
      <schemaSpec ident="syriacaPlaces" prefix="tei_" source="syriacaAll.compiled.odd" xml:lang="en" defaultExceptions="http://www.tei-c.org/ns/1.0 teix:egXML​ http://www.example.org/ns/">
        <moduleRef key="tei"/>
        <moduleRef key="certainty" include="precision"/>
        <moduleRef key="core" include="abbr author bibl biblScope choice citedRange date desc editor expan foreign listBibl measure name note orig p ptr quote reg ref resp respStmt title"/>
        <moduleRef key="header" include="authority availability catDesc category change classDecl edition editionStmt editorialDecl encodingDesc fileDesc funder idno langUsage licence principal profileDesc publicationStmt revisionDesc seriesStmt sourceDesc sponsor taxonomy teiHeader titleStmt"/>
        <moduleRef key="linking" include="link"/>
        <moduleRef key="namesdates" include="event geo listPlace listRelation location offset persName place placeName relation state"/>
        <moduleRef key="tagdocs" include="gi"/>
        <moduleRef key="textstructure" include="TEI body text"/>
        <classRef key="att.global.analytic"/>
        <classRef key="att.global.change"/>
        
        
        
        <elementSpec ident="bibl" module="core" mode="change">
          
        </elementSpec>
        
             
        
        
        <elementSpec ident="body" module="textstructure" mode="change">
          <content>
            <elementRef key="listPlace" minOccurs="1" maxOccurs="1"/>
          </content>
          <remarks mode="replace">
            <p>The <gi>body</gi> element of a Syriaca.org place record must contain a <gi>listPlace</gi> element.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="date" module="namesdates" mode="change">
          <attList>
            <attDef ident="resp" mode="delete"/>
            <attDef ident="source" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        
        <elementSpec ident="desc" module="core" mode="change">
          <constraintSpec ident="documentation-on-desc" scheme="schematron">
            <constraint>
              <sch:rule context="tei:place/tei:desc">
                <sch:report test="@resp and @source">Only one of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
              <sch:rule context="tei:place/tei:desc[not(tei:quote)]">
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:event/tei:desc">
                <sch:report test="@resp or @source">Documentation using @resp or @source should go on the parent &lt;event&gt; element.</sch:report>
              </sch:rule>
              <sch:rule context="tei:location/tei:desc">
                <sch:report test="@resp or @source">Documentation using @resp or @source should go on the parent &lt;location&gt; element.</sch:report>
              </sch:rule>
              <sch:rule context="tei:state/tei:desc">
                <sch:report test="@resp or @source">Documentation using @resp or @source should go on the parent &lt;state&gt; element.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="confession-desc" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:state/tei:desc">
                <!-- Revisit this. It works but it is inelegent. 
            The problem is that it is difficult to combine regex and schematron functions to move between lowercase w/ hypens to uppercase without.-->
                <sch:let name="confessionDoc" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/confessions.xml')"/>
                <sch:let name="confessionLabels" value="$confessionDoctei:text//tei:item/tei:label"/>
                <sch:let name="stateRefPart" value="substring-after(parent::tei:state/@ref, '#')"/>
                <sch:let name="spaceTo-" value="for $i in . return(replace($i, ' ', '-'))"/>
                <sch:let name="labelToRef" value="for $i in $spaceTo- return lower-case($spaceTo-)"/>
                <sch:assert test="parent::tei:state/@type='confession'">A &lt;label&gt; element can only be used when parent &lt;state&gt; element has @type="confession"</sch:assert>
                <sch:assert test="                   every $i in $labelToRef                   satisfies $i = $stateRefPart">
                  The text node in the &lt;label&gt; element must correspond to the @ref attribute on the parent &lt;state&gt;: 
                  <sch:value-of select="parent::tei:state/@ref"/>.
                </sch:assert>
                <sch:assert test="                   every $i in .                   satisfies $i = $confessionLabels">
                  The text node in the &lt;label&gt; element must be one of the following: <sch:value-of select="string-join($confessionLabels, '; ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        
        
        
        <elementSpec ident="event" module="namesdates" mode="change">
          <constraintSpec ident="xmlID-on-event" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:event[@type='attestation']">
                <sch:let name="docURIno" value="//tei:publicationStmt/tei:idno/substring-before(substring-after(substring-after(., 'http://syriaca.org/'), '/'), '/tei')"/>
                <sch:assert test="matches(./@xml:id, concat('attestation', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'attestation<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="documentation-on-event" scheme="schematron">
            <constraint>
              <sch:rule context="tei:place/tei:event">
                <sch:report test="@resp and @source">Only one of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
              <sch:rule context="tei:place/tei:event[not(tei:quote)]">
                <sch:assert test="@source">A @source attribute must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <desc>The <gi>event</gi> element requires a <att>type</att> attribute.</desc>
              <valList type="closed" mode="replace">
                <valItem ident="attestation">
                  <desc>An event that attests to the entity described in the document</desc>
                </valItem>
                <valItem ident="other">
                  <desc>Any event that does something other than attest to the entity described in the document</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="idno" module="header" mode="change">
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <desc>The <att>type</att> attribute on <gi>idno</gi> defines the kind of identifier
                contained in the text value. In the Gazetteer, the only type of <gi>idno</gi> used is "URI".</desc>
              <valList mode="replace" type="closed">
                <valItem ident="URI">
                  <desc>A Uniform Resource Identifier.</desc>
                </valItem>
                <valItem ident="deprecated">
                  <desc>For URIs that are no longer in use.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="listPlace" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <elementRef key="place" minOccurs="1" maxOccurs="1"/>
            <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
          </content>
          <remarks mode="add">
            <p>The <gi>listPlace</gi> element of a place record must contain a <att>place</att> 
              element and may contain a <gi>listRelation</gi> element.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="location" module="namesdates" mode="change">
          <!--<classes mode="change">
            <memberOf key="att.global.rendition" mode="delete"/><!-\- not deleted -\->
            <memberOf key="att.global.linking" mode="delete"/><!-\- not deleted -\->
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            
          </classes>-->
          <content>
            <alternate>
              <elementRef key="geo"/>
              <elementRef key="desc"/>
            </alternate>
          </content>
          <constraintSpec ident="location-children" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:location[@type='gps']">
                <sch:assert test="./tei:geo">
                  A &lt;location&gt; element of @type="gps" requires a child element &lt;geo&gt;.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:location[@type='relative']">
                <sch:assert test="./tei:desc">
                  A &lt;location&gt; element of @type="relative" requires a child elements: &lt;desc&gt;.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="documentation-on-location" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:location">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
              <sch:rule context="tei:place/tei:location[not(tei:quote)]">
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <valList mode="replace" type="closed">
                <valItem ident="gps"/>
                <valItem ident="relative"/>
              </valList>
            </attDef>
            <attDef ident="subtype" mode="delete"/>
            <attDef ident="source" mode="change">
              <desc>
                In most cases the <gi>location</gi> element will have a <att>source</att> attribute pointing to the <gi>bibl</gi> element that is the 
                source of that location information. In instances were the location information has been collected by a Syriaca.org contributor but is
                not attested in print, a <att>resp</att> is used with a value of 'http://syriaca.org'.
              </desc>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="measure" module="core" mode="change">
          <!--<classes mode="change"><!-\- all deleted -\->
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.global.rendition" mode="delete"/>
            <memberOf key="att.global.linking" mode="delete"/>
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            <memberOf key="att.global.responsibility" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>-->
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="note" module="core" mode="change">
          <constraintSpec ident="documentation-on-note" scheme="schematron">
            <constraint>
              <sch:rule context="tei:place/tei:note">
                <sch:report test="@resp and @source">Only one of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
              <sch:rule context="tei:place/tei:note[not(tei:quote)]">
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="note-type-deprecation" scheme="schematron"> <!-- Changes to relation elements will require this to change. -->
            <constraint>
              <sch:rule context="//tei:body//tei:note[@type='deprecation']">
                <sch:assert test="./@target">
                  A &lt;note&gt; element of @type="deprecation" must have a @target attribute.
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:body//tei:note[@type='deprecation']/@target">
                <sch:let name="nameIDs" value="//tei:place/tei:placeName/@xml:id"/>
                <sch:let name="IDvalues" value="for $i in $nameIDs return concat('#', $i)"/>
                <sch:assert test="                   every $i in tokenize(., ' ')                   satisfies $i = $IDvalues">
                  This @target attribute on &lt;note&gt; of @type="deprecation" can take one or more of the following value 
                  separated by a space: 
                  <sch:value-of select="string-join($IDvalues, ' | ')"/>.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        
        
        <elementSpec ident="offset" module="namesdates" mode="change">
          <!--<classes mode="change"><!-\- all deleted -\->
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.datable.w3c" mode="delete"/>
            
            <memberOf key="att.datable.custom" mode="delete"/>
            
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.global.rendition" mode="delete"/>
            <memberOf key="att.global.linking" mode="delete"/>
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            <memberOf key="att.global.responsibility" mode="delete"/>
            <memberOf key="att.global.source" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>-->
          <!--<attList>
            
            <attDef ident="ref" mode="change" usage="req"/>
          </attList>-->
        </elementSpec>
        
        
        
        
        <elementSpec ident="persName" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
          </classes>
          <attList>
            <attDef ident="sort" mode="delete"/>
            <attDef ident="role" mode="delete"/>
            <attDef ident="key" mode="delete"/>
            <attDef ident="srophe:tags" mode="delete"/>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="place" module="namesdates" mode="change">
          <classes mode="change">
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.sortable" mode="delete"/>
          </classes>
          <content>
            <elementRef key="placeName" minOccurs="1" maxOccurs="unbounded"/>
            <elementRef key="desc" minOccurs="1" maxOccurs="unbounded"/>
            <elementRef key="location" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
            <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
            <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <constraintSpec ident="abstract-in-place" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:body//tei:place">
                <sch:report test="count(//tei:desc[@type='abstract']) lt 1">
                  Every &lt;place&gt; element must have at least one &lt;desc&gt; element with @type="abstract".
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="subtype" mode="delete"/>
            <attDef ident="type" mode="replace" usage="req">
              <valList type="closed" mode="replace"> <!-- This should be migrated to LOD when possible -->
                <valItem ident="building">
                  <desc>A construction for which there is no narrower category, such as a church or mosque. Examples of this type include palaces and named city gates.</desc>
                </valItem>
                <valItem ident="cemetery">
                </valItem>
                <valItem ident="church">
                </valItem>
                <valItem ident="composite">
                  <desc>A named place concept which merges multiple distinct place types, such as a city and a diocese. More specific types are preferred.</desc>
                </valItem>
                <valItem ident="designated-space">
                  <desc>An area with artificial boundaries which is not necessarily built up, such as a cemetery, town square, or polo ground.</desc>
                </valItem>
                <valItem ident="diocese">
                  <desc>An ecclesiastical province governed by a bishop, archbishop, or metropolitan.</desc>
                </valItem>
                <valItem ident="fortification">
                  <desc>A military outpost such as a fort or a castle.</desc>
                </valItem>
                <valItem ident="island">
                  <desc>A land-mass smaller than a continent surrounded on all sides by water.</desc>
                </valItem>
                <valItem ident="madrasa">
                  <desc>A building or space designated for instruction in the Islamic sciences.</desc>
                </valItem>
                <valItem ident="monastery">
                  <desc>A whole monastic complex, including living quarters for the monks or nuns, the church(es), and potentially a refectory, library, school, or other part.</desc>
                </valItem>
                <valItem ident="mosque">
                  <desc>A building or designated space used for Muslim congregational prayers. It can be part of a larger building complex.</desc>
                </valItem>
                <valItem ident="mountain">
                  <desc>An elevated physical feature, from Mt. Ararat down to a prominent hill.</desc>
                </valItem>
                <valItem ident="natural-feature">
                  <desc>A natural feature for which there is no narrower category, such as a mountain or open water. Examples of this type include forests and hot springs.</desc>
                </valItem>
                <valItem ident="open-water">
                  <desc>A broad category for seas, lakes, oceans, and ponds.</desc>
                </valItem>
                <valItem ident="parish">
                  <desc>An ecclesiastical region below a diocese, presided over by a priest.</desc>
                </valItem>
                <valItem ident="province">
                  <desc>A political unit subject to a "state" but larger than a city. States often have multiple levels of administrative units (e.g. the late Ottoman vilayets, sanjaks, kazas, and nahiyes), all of which can be indicated as a "province."</desc>
                </valItem>
                <valItem ident="quarter">
                  <desc>A subdivision of an urban center.</desc>
                </valItem>
                <valItem ident="region">
                  <desc>A term indicating a geographic extent larger than a city, without a corresponding politico-administrative apparatus. The size could range from a small valley to an entire continent.</desc>
                </valItem>
                <valItem ident="river">
                  <desc>A stream of water of whatever size, from the smallest creek to the Amazon. Wadis are also included, even if they are not filled with water year-round.</desc>
                </valItem>
                <valItem ident="settlement">
                  <desc>Any collection of civilian residences, from the smallest village to the largest metropolis.</desc>
                </valItem>
                <valItem ident="state">
                  <desc>A sovereign government such as an empire, kingdom, caliphate, or independent emirate.</desc>
                </valItem>
                <valItem ident="synagogue">
                  <desc>A building designated for use in Jewish worship.</desc>
                </valItem>
                <valItem ident="temple">
                  <desc>A building designated for use in pagan worship.</desc>
                </valItem>
                <valItem ident="unknown">
                  <desc>A place whose name is known, but what sort of place it represents is unknown.</desc>
                </valItem>
                <valItem ident="valley">
                </valItem>
              </valList>
            </attDef>
          </attList>
          <remarks mode="add">
            <p>Within each <gi>place</gi> element will be a series of: 
              one or more <gi>placeName</gi> elements,
              zero or more <gi>location</gi> elements,
              zero or more <gi>event</gi> elements,
              zero or more <gi>state</gi> elements,
              one or more <gi>note</gi> description elements,
              one or more <gi>idno</gi> elements, and
              one or more <gi>bibl</gi> elements.
            </p>
          </remarks>
        </elementSpec>
        
        
        
        <elementSpec ident="placeName" module="namesdates" mode="change">
          <constraintSpec ident="documentation-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
              <sch:rule context="tei:place//tei:placeName[not(parent::tei:place)]">
                <sch:report test="@source and @resp">Neither of the attributes @resp and @source may be supplied.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="placeName-content" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:place/tei:placeName">
                <sch:assert test="string-length(.) gt 0">The &lt;placeName&gt; element cannot be empty.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <!-- This works in the schematron but not when placed into the ODD and converted to RelaxNG. There is a namespace issue I will try to troubleshoot.
            <constraintSpec ident="langHeadword" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:let name="langsOfHW" value="//tei:place/tei:placeName[@srophe:tags='#syriaca-headword']/@xml:lang"/>
                <sch:assert test="count(./parent::tei:place/tei:placeName[@xml:lang='en' and @srophe:tags='#syriaca-headword']) = 1">
                  There can be one and only one &lt;placeName&gt; element with the combination of @srophe:tags="#syriaca-headword" and @xml:lang="en".
                </sch:assert>
                <sch:assert test="count(distinct-values($langsOfHW)) = count($langsOfHW)">
                  There cannot be more than one headword (@srophe:tags="#syriaca-headword") per &lt;placeName&gt; with the same language (@xml:lang).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>-->
          <constraintSpec ident="xmlID-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text/tei:place/tei:placeName">
                <sch:let name="docURIno" value="//tei:publicationStmt/tei:idno[@type='URI']/substring-before(substring-after(substring-after(., 'http://syriaca.org/'), '/'), '/tei')"/>
                <sch:assert test="matches(./@xml:id, concat('name', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'name<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="xmlLang-on-placeName" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:place/tei:placeName">
                <sch:assert test="./@xml:lang">A &lt;placeName&gt; element that is the direct child of the &lt;place&gt; element must have an @xml:lang attribute.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" mode="change">
              <desc>
                The <gi>placeName</gi> element requires an <att>xml:id</att> attribute whose value is the concatenation of "name", 
                the Syriaca.org ID number of this place (i.e. the last element of the URI), a ‘-’, and the number of this name element in order.
              </desc>
            </attDef>
            <attDef ident="xml:lang" mode="change">
              <desc>
                The language of the name should be indicated in an <att>xml:lang</att> attribute of the <gi>placeName</gi> element, 
                whose value is derived from the the <ref target="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO-639-1 or ISO-639-2 standards</ref>. 
                In particular, "en" should be used for "English", "ar" for "Arabic", and "syr" for Syriac. Syriaca.org is not using "syc" for 
                Syriac to avoid the judgment of what constitutes "classical." In the case of vocalized Syriac, the <att>xml:lang</att> attribute 
                should be augmented with a script indication: either "-Syrj" to indicate West Syrian vocalization or "-Syrn" to indicate East Syrian 
                vocalization. Thus the <att>xml:lang</att> attribute will have a value of "syr-Syrj" for vocalized Western Syriac and "syr-Syrn" 
                for vocalized Eastern Syriac. The <att>xml:lang</att> attribute for an unvocalized Syriac name form, such as Syriaca.org’s headword 
                form, should be simply "syr".
              </desc>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        
        
        <elementSpec ident="relation" module="namesdates" mode="change">
          <constraintSpec ident="documentation-on-relation" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:relation">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="atts-on-relation" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active | tei:text//tei:relation/@passive">
                <sch:let name="placeIndex" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/indexes/places.xml')"/>
                <sch:let name="placeURIs" value="$placeIndex//tei:place/@ref"/>
                <sch:assert test="                   every $i in tokenize(., ' ')                   satisfies $i = $placeURIs">
                  This attribute contains one or more place URIs not in use in Syriaca.org data. Note that all place URIs take the form 'http://syriaca.org/place/{\d+?}' (where {\d+?} is a number).
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active">
                <sch:let name="docURI" value="//tei:publicationStmt/tei:idno/substring-before(., '/tei')"/>
                <sch:assert test="contains(., $docURI)">
                  This attribute must contain the URI for this document's place: <sch:value-of select="$docURI"/>.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='syriaca:distinct-entity']">
                <sch:assert test="@type='disambiguation' and @mutual and not(@subtype)">
                  For a 'distinct entity' relationship use @type="disambiguation", no @subtype, and a @mutual attribute.</sch:assert>
                <sch:report test="@type='see-also' or @type='contained-within'">
                  With a 'distinct entity' relationship, @type="see-also" and @type="contained-within" not allowed.</sch:report>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='syriaca:possibly-identical']">
                <sch:assert test="@type='disambiguation' and @mutual and not(@subtype)">
                  For a 'possibly identical' relationship use @type="disambiguation", no @subtype, and a @mutual attribute.</sch:assert>
                <sch:report test="@type='see-also' or @type='contained-within'">
                  With a 'possibly identical' relationship, @type="see-also" and @type="contained-within" are not allowed.</sch:report>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='syriaca:share-a-name']">
                <sch:assert test="@type='disambiguation' and @subtype='share-a-name' and @mutual">
                  For a 'share-a-name' relationship, use @type="disambiguation", @subtype="share-a-name", and a @mutual attribute.</sch:assert>
                <sch:report test="@type='see-also' or @type='contained-within'">
                  With a 'share-a-name' relationship, @type="see-also" and @type="contained-within" are  not allowed.</sch:report>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='syriaca:share-a-name-search-together']">
                <sch:assert test="@type='disambiguation' and @subtype='share-a-name' and @mutual">
                  For a 'share-a-name-search-together' relationship, use @type="disambiguation", @subtype="share-a-name", and a @mutual attribute.</sch:assert>
                <sch:report test="@type='see-also' or @type='contained-within'">
                  With a 'share-a-name-search-together' relationship, @type="see-also" and @type="contained-within" are not allowed.</sch:report>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='skos:related']">
                <sch:assert test="@type='see-also' and @mutual and not(@subtype)">
                  For a 'related' relationship, use @type="see-also", no @subtype, and a @mutual attribute.</sch:assert>
                <sch:report test="@type='disambiguation' or @type='contained-within'">
                  With a 'related' relationship, @type="disambiguation" and @type="contained-within" not allowed.</sch:report>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='skos:broader']">
                <sch:assert test="@type='contained-within' and @active and not(@subtype)">
                  For a 'broader' relationship, use @type="contained-within", no @subtype, and @active/@passive attributes.</sch:assert>
                <sch:report test="@type='see-also' or @type='disambiguation'">
                  With a 'broader' relationship, @type="see-also" and @type="disambiguation" not allowed.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="relation-children" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:relation[@ref='skos:broader'] | //tei:body//tei:relation[@ref='syriaca:distinct-entity']">
                <sch:assert test="tei:desc">
                  A &lt;desc&gt; is required as child of &lt;relation&gt;.
                </sch:assert>
              </sch:rule>
              <sch:rule context="tei:text//tei:relation[@ref='skos:related'] | //tei:body//tei:relation[@ref='syriaca:share-a-name'] | //tei:body//tei:relation[@ref='syriaca:share-a-name-search-together']">
                <sch:report test="tei:desc">
                  A &lt;desc&gt; may not appear here.
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="replace" usage="req">
              <valList type="closed">
                <valItem ident="disambiguation">
                  <desc>Used for a group of relationships that disambiguate between entities.</desc>
                </valItem>
                <valItem ident="contained-within">
                  <desc>Used for a nesting relationship and indicates when are larger entity contains the subject of an authority file.</desc>
                </valItem>
                <valItem ident="see-also">
                  <desc>Used when the encoder wants to point user to another entity they may want to see.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" mode="change">
              <valList type="closed" mode="change">
                <valItem ident="share-a-name">
                  <desc>Used with disambiguation relationships when the entities have the same or a very similar name. 
                    This could either be a situation in which two otherwise unrelated places share a name, i.e. two 
                    churches in different locations with the name "Saint George", or a situation in which a city, 
                    the diocese associated with that city, and the region around that city all share a name.
                  </desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="ref" mode="replace" usage="req">
              <valList type="closed">
                <valItem ident="syriaca:distinct-entity">
                  <desc>Used to distinguish between entities that have been confused in the scholarly literature or might be confused by users.</desc>
                </valItem>
                <valItem ident="syriaca:possibly-identical">
                  <desc>Used to indicate that even though Syriaca.org has identified this location as a distinct entity, it is possible that this place is the same an another entity.</desc>
                </valItem>
                <valItem ident="syriaca:share-a-name">
                  <desc>Used to indicate when entities share a name but remain distinct; i.e. when different settlements or churches share a name.</desc>
                </valItem>
                <valItem ident="syriaca:share-a-name-search-together">
                  <desc>Used to indicate when closely related entities share a name but remain distinct and when ancient sources sometimes conflate them; i.e. when a settlement, region, and diocese bear the same name.</desc>
                </valItem><valItem ident="skos:related">
                  <desc>Used for a "see-also" relationship.</desc>
                </valItem>
                <valItem ident="skos:broader">
                  <desc>Used for a nesting relationship and indicates when are larger entity contains the subject of an authority file.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
        <elementSpec ident="seriesStmt" module="header" mode="change">
          <constraintSpec ident="seriesStmt-content" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:seriesStmt//tei:title[@level='s']">
                <!-- Add additional values with an "or" operator if there are multiple series levels associated with a document. -->
                <sch:assert test="matches(., 'The Syriac Gazetteer') ">
                  The text node of this &lt;title&gt; element must be "The Syriac Gazetteer". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt//tei:title[node() = 'The Syriac Gazetteer']">
                <!-- Add additional rules with appropriate contexts when adding additional monograph values above. -->
                <sch:assert test="./following-sibling::tei:idno/node() = 'http://syriaca.org/geo'">
                  A &lt;title&gt; containing "The Syriac Gazetteer" requires a following sibling &lt;idno&gt; element containing "http://syriaca.org/geo'. 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt/tei:title[@level='m']">
                <sch:assert test="matches(., 'Beth Qaṭraye Gazetteer')">
                  <!-- Add additional monograph values with an "or" operator as needed. -->
                  The text node of this &lt;title&gt; element must be "Beth Qaṭraye Gazetteer". 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title='Beth Qaṭraye Gazetteer']/tei:idno">
                <!-- Add additional rules with appropriate contexts when adding additional monograph values above. -->
                <sch:assert test="matches(., 'http://syriaca.org/bethqatraye')">
                  The text node of this &lt;idno&gt; element must be "http://syriaca.org/bethqatraye'. 
                </sch:assert>
              </sch:rule>
              <sch:rule context="//tei:seriesStmt[tei:title='Beth Qaṭraye Gazetteer']/tei:biblScope/@n">
                <!-- Add an additional rule with appropriate context/assert if there are multiple monographs. -->
                <sch:assert test=". = '1'">
                  The @n attribute must be "1" since the Beth Qaṭraye Gazetteer is volume 1 of The Syriac Gazetteer.
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        
        
        
        <elementSpec ident="state" module="namesdates" mode="change">
          <constraintSpec ident="xmlID-on-state" scheme="schematron">
            <constraint>
              <sch:rule context="tei:text//tei:state[@type='confession']">
                <sch:let name="docURIno" value="//tei:publicationStmt/tei:idno/substring-before(substring-after(substring-after(., 'http://syriaca.org/'), '/'), '/tei')"/>
                <sch:assert test="matches(./@xml:id, concat('confession', $docURIno, '-', '\d+$'))">
                  The required @xml:id must be 'confession<sch:value-of select="$docURIno"/>-{\d+$}' (where {\d+$} is a number).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="documentation-on-state" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:state">
                <sch:report test="@source and @resp">Only one of the attributes @resp and @source may be supplied.</sch:report>
                <sch:assert test="@resp or @source">One of the attributes @resp or @source must be supplied.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="state-type-existence" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:state[@type='existence']">
                <sch:assert test="attribute::source or attribute::resp">
                  A &lt;state&gt; of @type="existence" must have either a @source attribute (preferred when available) or a @resp attribute.
                </sch:assert>
                <sch:report test="attribute::source and attribute::resp">
                  A &lt;state&gt; of @type="existence" may not have both a @source attribute (the preferred when available) and a @resp attribute.
                </sch:report>
                <sch:report test="@xml:id">
                  A &lt;state&gt; of @type="existence" may not may not take an @xml:id attribute.
                </sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="state-type-confession" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:state[@type='confession']">
                <sch:let name="docURIno" value="//tei:publicationStmt/tei:idno/substring-before(substring-after(substring-after(., 'http://syriaca.org/'), '/'), '/tei')"/>
                <sch:assert test="@ref">A &lt;state&gt; element with @type="confession" must have a @ref attribute.</sch:assert>
              </sch:rule>
              <sch:rule context="//tei:state/@ref">
                <sch:let name="confessionDoc" value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/confessions.xml')"/>
                <sch:let name="confessionIDs" value="$confessionDoctei:text//tei:item/@xml:id"/>
                <sch:let name="confessionPtrs" value="for $i in $confessionIDs return concat('#', $i)"/>
                <sch:let name="confessionRefValues" value="for $i in $confessionPtrs return concat('http://syriaca.org/documentation/confessions.xml', $i)"/>
                <sch:assert test="                   every $i in .                   satisfies $i = $confessionRefValues">
                  The acceptable values of @ref are 'http://syriaca.org/documentation/confessions.xml' followed by one of the following:
                  <sch:value-of select="string-join($confessionPtrs, '; ')"/>
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="change" usage="req">
              <valList type="closed" mode="change">
                <valItem ident="confession">
                  <desc>identifies the presence of a confessional community in this place</desc>
                </valItem>
                <valItem ident="existence">
                  <desc>indicates that the place existed</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        
      </schemaSpec>
    </body>
  </text>
</TEI>